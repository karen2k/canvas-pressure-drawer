// Generated by CoffeeScript 1.6.3
(function() {
  Array.prototype.last = function() {
    return this[this.length - 1];
  };

  window.drawer = function(canvas_id) {
    var addCanvasEventsListeners, canvas, context, drawLine, id, logging, onCanvasMouseDown, onCanvasMouseMove, onCanvasMouseUp, p, points, prevX, prevY, pushPoint, reDrawSpline, setPrevXY, strokeStyle, t, timer, timerMin, __construct;
    t = this;
    canvas = null;
    context = null;
    logging = true;
    prevX = 0;
    prevY = 0;
    points = [];
    strokeStyle = 'black';
    timer = 0;
    timerMin = 0;
    p = function(m) {
      if (logging) {
        return console.log(m);
      }
    };
    id = function(id) {
      return document.getElementById(id);
    };
    __construct = function() {
      canvas = id(canvas_id);
      context = canvas.getContext('2d');
      return addCanvasEventsListeners();
    };
    addCanvasEventsListeners = function() {
      return canvas.addEventListener('mousedown', onCanvasMouseDown);
    };
    onCanvasMouseDown = function(e) {
      setPrevXY(e.offsetX, e.offsetY);
      document.addEventListener('mouseup', onCanvasMouseUp);
      return canvas.addEventListener('mousemove', onCanvasMouseMove);
    };
    onCanvasMouseUp = function(e) {
      document.removeEventListener('mouseup', onCanvasMouseUp);
      return canvas.removeEventListener('mousemove', onCanvasMouseMove);
    };
    onCanvasMouseMove = function(e) {
      if (((new Date()).getTime() - timer) < timerMin) {
        return;
      }
      timer = (new Date()).getTime();
      pushPoint(e.offsetX, e.offsetY);
      return setPrevXY(e.offsetX, e.offsetY);
    };
    setPrevXY = function(x, y) {
      var _ref;
      return _ref = [x, y], prevX = _ref[0], prevY = _ref[1], _ref;
    };
    pushPoint = function(x, y) {
      var prevPoint;
      prevPoint = points.last();
      points.push({
        x: x,
        y: y
      });
      return reDrawSpline();
    };
    reDrawSpline = function() {
      var N, a0, a1, a2, a3, b0, b1, b2, b3, i, j, x, xA, xB, xC, xD, y, yA, yB, yC, yD, _i, _j, _ref;
      if (!(points.length > 1)) {
        return;
      }
      context.clearRect(0, 0, 640, 480);
      N = 30;
      strokeStyle = 'white';
      context.beginPath();
      context.moveTo(points[0].x, points[0].y);
      for (i = _i = 1, _ref = points.length - 3; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        xA = points[i - 1].x;
        xB = points[i].x;
        xC = points[i + 1].x;
        xD = points[i + 2].x;
        yA = points[i - 1].y;
        yB = points[i].y;
        yC = points[i + 1].y;
        yD = points[i + 2].y;
        a3 = (-xA + 3 * (xB - xC) + xD) / 6.0;
        a2 = (xA - 2 * xB + xC) / 2.0;
        a1 = (xC - xA) / 2.0;
        a0 = (xA + 4 * xB + xC) / 6.0;
        b3 = (-yA + 3 * (yB - yC) + yD) / 6.0;
        b2 = (yA - 2 * yB + yC) / 2.0;
        b1 = (yC - yA) / 2.0;
        b0 = (yA + 4 * yB + yC) / 6.0;
        for (j = _j = 0; 0 <= N ? _j <= N : _j >= N; j = 0 <= N ? ++_j : --_j) {
          t = j / N;
          x = ((a3 * t + a2) * t + a1) * t + a0;
          y = ((b3 * t + b2) * t + b1) * t + b0;
          context.lineTo(x, y);
        }
      }
      context.strokeStyle = strokeStyle;
      context.lineWidth = 2;
      context.lineCap = 'round';
      return context.stroke();
    };
    drawLine = function(x0, y0, x1, y1) {
      var controlX, controlY;
      controlX = x0 + (x1 - x0) / 2;
      controlY = y0 + (y1 - y0) / 2;
      context.beginPath();
      context.moveTo(x0, y0);
      context.quadraticCurveTo(controlX, controlY, x1, y1);
      context.strokeStyle = strokeStyle;
      context.lineWidth = 2;
      context.lineCap = 'round';
      return context.stroke();
    };
    return __construct();
  };

}).call(this);
